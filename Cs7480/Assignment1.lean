import Mathlib.CategoryTheory.Category.Basic
import Mathlib.Data.Fintype.Defs
import Mathlib.Data.Finset.Powerset

/-
Problem 1: $\mathsf{Formula}$: the category of syntactic Boolean formulae and entailment]
  Consider the following grammar of Boolean formulae:
  \begin{align}
    \varphi, \psi ::= x \mid \varphi \land \psi \mid \varphi \lor \psi \mid \neg \psi
  \end{align}
  Fix a global finite set of variable names $\Omega$, and assume $x \in \Omega$.
  Then, we can give a semantics to Boolean formulae in terms of substitutions.
  A
  substitution $\gamma$ is a function $\Omega \to \{\top, \bot\}$ that maps each variable
  to a truth value. Then, we can define the semantics of formulae inductively:

  \begin{align*}
    \dbracket{x}(\gamma) &= \gamma(x)\\
    \dbracket{\varphi \land \psi}(\gamma) &= \begin{cases}
    \top \quad& \text{if } \dbracket{\varphi}(\gamma) = \top, \dbracket{\psi}(\gamma) = \top\\
    \bot \quad& \text{otherwise}
    \end{cases}\\
    \dbracket{\varphi \lor \psi}(\gamma) &= \begin{cases}
    \bot \quad& \text{if } \dbracket{\varphi}(\gamma) = \bot, \dbracket{\psi}(\gamma) = \bot\\
    \top \quad& \text{otherwise}
    \end{cases}\\
    \dbracket{\neg \varphi}(\gamma) &= \begin{cases}
    \top \quad& \text{if } \dbracket{\varphi}(\gamma) = \bot\\
    \bot \quad& \text{if } \dbracket{\varphi}(\gamma) = \top
    \end{cases}
  \end{align*}

  The \emph{set of models}, written $\mathsf{Mods}(\varphi)$, is the set of all substitutions
  that evaluate to
  $\top$, i.e. $\mathsf{Mods}(\varphi) = \{\gamma \mid \dbracket{\varphi}(\gamma) = \top\}$.
  We say a formula
  $\varphi$ \emph{semantically entails} a formula $\psi$, written $\varphi \models \psi$,
  if $\mathsf{Mods}(\varphi) \subseteq \mathsf{Mods}(\psi)$.


    Consider the following components of a category whose objects are
    Boolean formula and whose morphisms denote formula entailment:
    \begin{itemize}
      \item Let the set of objects $O$ be the set of all syntactic Boolean
      formulae generated by the above grammar.
      \item The set of morphisms $M$ consists of pairs $(\varphi, \psi)$ where
      $\varphi \models \psi$.
      \item Define $\mathsf{dom}(\varphi, \psi) = \varphi, \mathsf{cod}(\varphi, \psi) = \psi$
      \item Identity is defined by $\mathsf{id}(\phi) = (\phi, \phi)$
      \item Composition is defined by $\mathsf{comp}((\psi, \xi), (\varphi, \psi)) = (\varphi, \xi)$
    \end{itemize}
    Verify that the above satisfy the definition of a category.
    This will involve showing that some entailments are valid.
-/

inductive VarFormula (Name : Type) where
| Variable (name: Name)
| And (op1: VarFormula Name) (op2: VarFormula Name)
| Or (op1: VarFormula Name) (op2: VarFormula Name)
| Not (op: VarFormula Name)
deriving Repr, DecidableEq

inductive BoolFormula where
| Constant (value: Bool)
| And (op1: BoolFormula) (op2: BoolFormula)
| Or (op1: BoolFormula) (op2: BoolFormula)
| Not (op: BoolFormula)

namespace VarFormula

def substitute {Name : Type} (vf : VarFormula Name) (substitution : Name → Bool) : BoolFormula :=
  match vf with
  | Variable name => BoolFormula.Constant (substitution name)
  | And op1 op2 => BoolFormula.And (substitute op1 substitution) (substitute op2 substitution)
  | Or op1 op2 => BoolFormula.Or (substitute op1 substitution) (substitute op2 substitution)
  | Not op => BoolFormula.Not (substitute op substitution)

end VarFormula

namespace BoolFormula

def evaluate (formula : BoolFormula) : Bool :=
  match formula with
  | Constant value => value
  | And op1 op2 => and (evaluate op1) (evaluate op2)
  | Or op1 op2 => or (evaluate op1) (evaluate op2)
  | Not op => not (evaluate op)

end BoolFormula

namespace VarFormula

def models {Name : Type} [finite : Fintype Name] [deq : DecidableEq Name]
  (formula : VarFormula Name) : Finset (Name → Bool) :=
  -- 1. get the elements from `finite`
  -- 2. turn it into a Finset
  -- 3. create a Finset of every possible unique function Name → Bool
  -- 4. filter the Finset on the evaluation of the substitution of `formula` w/ each function
  let name_set := finite.elems
  let name_to_bool_set := name_set.powerset.image (fun set => fun name => decide (name ∈ set))
  name_to_bool_set.filter (fun set => (formula.substitute set).evaluate)

end VarFormula

instance {Name : Type} : CategoryTheory.Category (VarFormula Name) :=
  {
    Hom := sorry
    id := sorry
    comp := sorry
  }
