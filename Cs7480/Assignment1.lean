import Mathlib.CategoryTheory.Category.Basic
import Mathlib.Data.Fintype.Defs
import Mathlib.Data.Finset.Powerset
import Mathlib.CategoryTheory.Limits.Shapes.Terminal
import Mathlib.CategoryTheory.Limits.Shapes.Products
import Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts

open CategoryTheory

/-
Problem 1:
  Consider the following grammar of Boolean formulae:
  \begin{align}
    \varphi, \psi ::= x \mid \varphi \land \psi \mid \varphi \lor \psi \mid \neg \psi
  \end{align}
  Fix a global finite set of variable names $\Omega$, and assume $x \in \Omega$.
  Then, we can give a semantics to Boolean formulae in terms of substitutions.
  A
  substitution $\gamma$ is a function $\Omega \to \{\top, \bot\}$ that maps each variable
  to a truth value. Then, we can define the semantics of formulae inductively:

  \begin{align*}
    \dbracket{x}(\gamma) &= \gamma(x)\\
    \dbracket{\varphi \land \psi}(\gamma) &= \begin{cases}
    \top \quad& \text{if } \dbracket{\varphi}(\gamma) = \top, \dbracket{\psi}(\gamma) = \top\\
    \bot \quad& \text{otherwise}
    \end{cases}\\
    \dbracket{\varphi \lor \psi}(\gamma) &= \begin{cases}
    \bot \quad& \text{if } \dbracket{\varphi}(\gamma) = \bot, \dbracket{\psi}(\gamma) = \bot\\
    \top \quad& \text{otherwise}
    \end{cases}\\
    \dbracket{\neg \varphi}(\gamma) &= \begin{cases}
    \top \quad& \text{if } \dbracket{\varphi}(\gamma) = \bot\\
    \bot \quad& \text{if } \dbracket{\varphi}(\gamma) = \top
    \end{cases}
  \end{align*}

  The \emph{set of models}, written $\mathsf{Mods}(\varphi)$, is the set of all substitutions
  that evaluate to
  $\top$, i.e. $\mathsf{Mods}(\varphi) = \{\gamma \mid \dbracket{\varphi}(\gamma) = \top\}$.
  We say a formula
  $\varphi$ \emph{semantically entails} a formula $\psi$, written $\varphi \models \psi$,
  if $\mathsf{Mods}(\varphi) \subseteq \mathsf{Mods}(\psi)$.


    Consider the following components of a category whose objects are
    Boolean formula and whose morphisms denote formula entailment:
    \begin{itemize}
      \item Let the set of objects $O$ be the set of all syntactic Boolean
      formulae generated by the above grammar.
      \item The set of morphisms $M$ consists of pairs $(\varphi, \psi)$ where
      $\varphi \models \psi$.
      \item Define $\mathsf{dom}(\varphi, \psi) = \varphi, \mathsf{cod}(\varphi, \psi) = \psi$
      \item Identity is defined by $\mathsf{id}(\phi) = (\phi, \phi)$
      \item Composition is defined by $\mathsf{comp}((\psi, \xi), (\varphi, \psi)) = (\varphi, \xi)$
    \end{itemize}
    Verify that the above satisfy the definition of a category.
    This will involve showing that some entailments are valid.
-/

inductive Formula (Names : Type*) where
  | var (name : Names)
  | top
  | bot
  | and (φ : Formula Names) (ψ : Formula Names)
  | or (φ : Formula Names) (ψ : Formula Names)
  | not (φ : Formula Names)

def Subst (Names : Type*) := Names → Bool

def eval {Names : Type*} : Formula Names → Subst Names → Bool
  | Formula.var x, γ => γ x
  | Formula.top, _ => true
  | Formula.bot, _ => false
  | Formula.and φ ψ, γ => and (eval ψ γ) (eval φ γ)
  | Formula.or φ ψ, γ => or (eval ψ γ) (eval φ γ)
  | Formula.not φ, γ => not (eval φ γ)

-- the set of substitutions which evaluate to true
def Mods {Names : Type*} (φ : Formula Names) : Set (Subst Names) :=
  {γ | eval φ γ = true}

-- semantic entailment
def entails {Names : Type*} (φ ψ : Formula Names) : Prop :=
  Mods φ ⊆ Mods ψ

instance formulaCategory {Names : Type*} : Category (Formula Names) where
  -- Prop isn't in the correct type universe (because of Names), so we must lift it
  Hom φ ψ := PLift (entails φ ψ)
  -- straightforward-ly, the identity and composition functions
  id φ := by
    apply PLift.up
    intro γ hγ
    exact hγ
  comp {x y z} h₁ h₂ := by
    apply PLift.up
    apply PLift.down at h₁
    apply PLift.down at h₂
    intro γ hγ
    exact h₂ (h₁ hγ)
  -- because comp and id are straightforward, so are the left and right id composition laws
  id_comp := by
    simp only
    intro x y f
    trivial
  comp_id := by
    simp only
    intro x y f
    trivial
  -- assoc is also pretty straightforward, but not as easy as id_comp and comp_id
  assoc {w x y z} h₁ h₂ h₃ := by
    rw [PLift.down]
    exact h₃

/-
Problem 2:
    Consider the following components of a category whose objects are finite
    transition systems and whose morphisms denote ``abstractions'' of transition systems:
    \begin{itemize}
      \item Objects are pairs $(X, \alpha)$ where $X$ is a finite set and
      $\alpha : X \rightarrow X$ is a function.
      \item Morphisms are triples $((X,\alpha), f, (Y, \beta))$
      where (1) $f$ is a function $f : X \to Y$, and (2)
      $f$ satisfies
       $f \circ \alpha = \beta \circ f$. These morphisms can be drawn
      as commutative squares:
      \begin{center}
        % https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAA0QBfU9TXfIRRkAjFVqMWbTjz7Y8BIiPLj6zVohABNbrxAZ5gpaTHU1UzTq7iYUAObwioAGYAnCAFskZEDghIAJjNJDRBnXRd3L0RlX39EAGZg9TZw2TCo72o-JFjzUIAdAsY0AAs6CIzPQOz4pIkUzSKAIxgcCusuIA
\begin{tikzcd}
  X \arrow[r, "f"] \arrow[d, "\alpha"] & Y \arrow[d, "\beta"] \\
  X \arrow[r, "f"]                     & Y
  \end{tikzcd}
      \end{center}
      \item The domain of a morphism is:
      $$
      \mathsf{dom}\left( \begin{tikzcd}
  X \arrow[r, "f"] \arrow[d, "\alpha"] & Y \arrow[d, "\beta"] \\
  X \arrow[r, "f"]                     & Y
  \end{tikzcd}
\right) = (X, \alpha)
      $$
      \item The codomain of a morphism is:
      $$
      \mathsf{dom}\left( \begin{tikzcd}
  X \arrow[r, "f"] \arrow[d, "\alpha"] & Y \arrow[d, "\beta"] \\
  X \arrow[r, "f"]                     & Y
  \end{tikzcd}
\right) = (Y, \beta)
      $$
    \item The identity morphism is
      $\mathsf{id}((X, \alpha))=((X, \alpha), x \mapsto x, (X, \alpha))$
      where \(x \mapsto x\) denotes the identity function on \(X\).
    \item For two morphisms $((X, \alpha), f, (Y, \beta))$
    and $((Y, \beta), g, (Z, \gamma))$, composition is defined in terms of
    composition of functions:
    \begin{align*}
      ((Y, \beta), g, (Z, \gamma)) \circ ((X, \alpha), f, (Y, \beta)) =
      ((X, \alpha), g \circ f, (Z, \gamma))
    \end{align*}
    \end{itemize}
    \begin{enumerate}
      \item Show that $\mathsf{FinSet}^\circlearrowright$  satisfies the definition of a category.
    This will entail showing that $\mathsf{id}$ and $\mathsf{comp}$ define valid morphisms.
      \item Draw some internal pictures of morphisms in this category.
      \item In what sense does a morphism $((X, \alpha), f, (Y, \beta))$ define
      an abstraction of the transition system $(X, \alpha)$?
    \end{enumerate}
-/

structure FTS where
  (X : Type)
  [finite : Fintype X]
  (α : X → X)

structure FTSMorphism (φ ψ : FTS) where
  (f : φ.X → ψ.X)
  (satisfies : f ∘ φ.α = ψ.α ∘ f)

instance FTSCategory : Category FTS where
  Hom X Y := FTSMorphism X Y
  id A := {
    f := id
    satisfies := by simp only [Function.id_comp, Function.comp_id]
  }
  comp {x y z} h₁ h₂ := by
    obtain ⟨f, satisfies_f⟩ := h₁
    obtain ⟨g, satisfies_g⟩ := h₂
    exact {
      f := g ∘ f
      satisfies := by
        rw [Function.comp_assoc, satisfies_f, ← Function.comp_assoc, satisfies_g]
        rfl
    }
  id_comp := by simp only [Function.comp_id, implies_true]
  comp_id := by simp only [Function.id_comp, implies_true]
  assoc {w x y z} h₁ h₂ h₃ := by
    simp only [FTSMorphism.mk.injEq]
    rfl

/-
Problem 3:
    It is very common in category theory to form one category out of another category.
    Let's see an example of this.
    Let $\mathcal{C}$ be a category and $X$ be an object in $\mathcal{C}$.
    Then, the \emph{slice category} $\mathcal{C}/X$ is a category where:
    \begin{itemize}
      \item Objects are morphisms of $\mathcal{C}$ with codomain $X$, i.e.
      $O = \{A \xrightarrow{f} X \mid A \in \mathcal{C}\}$
      \item Morphisms are triples $(A \xrightarrow{f} X, A \xrightarrow{h} B, B \xrightarrow{g} X)$
      satisfying $g \circ h = f$. These can be drawn as commutative triangles:
      $$
      M = \left\{\left.% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAEEQBfU9TXfIRQAmclVqMWbAELdeIDNjwEiARlKrx9Zq0QgAGt3EwoAc3hFQAMwBOEALZIyIHBCTqQDOgCMYDAAr8ykKeMFY4INTaUnoAFnLWdo6Izq5IohI6bFYJILYO7tRpiBnRuiCmRlxAA
      \begin{tikzcd}
      A \arrow[rr, "h"] \arrow[rd, "f"] &   & B \arrow[ld, "g"] \\
                                        & X &
      \end{tikzcd} \right|~ A \xrightarrow{h} B, A \xrightarrow{f} X, B \xrightarrow{g} X
      \text{are morphisms of \(\mathcal C\)}, f = g \circ h \right\}
      $$
    \end{itemize}
    Show that $\mathcal{C}/X$ is a category and identify the definition of $\mathsf{dom},
    \mathsf{cod}$, $\mathsf{id}$, and $\mathsf{comp}$.
-/

structure sliceObject (T : Type*) (C : Category T) (X : T) where
  (A : T)
  (morphism : C.Hom A X)

structure SliceMorphism
  {T : Type*} [C : Category T] {X : T} (φ ψ : sliceObject T C X)
where
  (h : C.Hom φ.A ψ.A)
  (satisfies : C.comp h ψ.morphism = φ.morphism)

instance sliceCategory
  {T : Type*} [C : Category T] {X : T} :
    Category (sliceObject T C X) where
  Hom φ ψ := SliceMorphism φ ψ
  id A := {
    h := C.id A.A
    satisfies := by exact Category.id_comp A.morphism
  }
  comp h₁ h₂ := {
    h := C.comp h₁.h h₂.h
    satisfies := by rw [Category.assoc, h₂.satisfies, h₁.satisfies]
  }
  comp_id := by simp only [Category.comp_id, implies_true]
  id_comp := by simp only [Category.id_comp, implies_true]
  assoc := by simp only [Category.assoc, implies_true]

/-
Problem 4:
    Recall the definition of STLC from Assignment 0.
    Contexts $\Gamma$ were defined inductively
    using the following grammar:
    \begin{equation*}
      \mathsf{Ctx} \ni \Gamma ::= \bullet \mid \Gamma, x\ofty A
    \end{equation*}
    where $\bullet$ denotes the empty context.
    It is equivalently possible to view contexts
    as a finite product, i.e.
    the context $x_1 \ofty A_1, \dots, x_n \ofty A_n$
    viewed as a list
    gets interpreted as the product
    $A_1 \times \cdots \times A_n$ (where $1$ is the empty product),
    and each variable $x_i$ is interpreted as a
    projection $\plproj{i}{} \ofty A_1 \times \cdots \times A_n \to A_i$.
    With this interpretation, STLC forms a category
    in the following sense:
    \begin{itemize}
      \item objects are types $A$;
      \item a morphism $A \to B$ is an equivalence class
      of STLC terms $[\judge{a\ofty A}{M}{B}]$,
      given by:
      \begin{equation*}
        [\judge{a\ofty A}{M}{B}] = [\judge{a\ofty A}{N}{B}]
        \Longleftrightarrow
        \judge{a\ofty A}{M \equiv N}{B}
      \end{equation*}
      \item Composition is given by substitution:
      \begin{equation*}
        [\judge{b\ofty B}{N}{C}] \circ [\judge{a\ofty A}{M}{B}] = [\judge{a\ofty A}{N[M/b]}{C}]
      \end{equation*}
      %% [Note the variable in context $x$ has the same name for all morphisms!];
      \item the identity morphism $\id_A: A \to A$ is given by the
        term $[\judge{a\ofty A}{a}{A}]$.
    \end{itemize}
    Prove that STLC satisfies the axioms of a category. You
    will find yourself proving some utility lemmas about substitution, which are
    proven using structural induction. If you want, you can prove those lemmas
    for practice, or simply state them.
-/

-- TODO

/-
Problem 5:
    Show that $\mathsf{Formula}$ has products and a terminal object. What do they mean logically?
-/

instance trueTerminal {Names : Type*} :
  @Limits.IsTerminal (Formula Names) formulaCategory Formula.top where
  lift := by
    intro s
    simp_all only [Limits.asEmptyCone_pt]
    tauto

instance formulaTerminal {Names : Type*} : Limits.HasTerminal (Formula Names) := by
  exact Limits.IsTerminal.hasTerminal trueTerminal

-- TODO: products and logical explanation

/-
Problem 6:
    Show that $\mathsf{FinSet}^\circlearrowright$ has products. Does it have a terminal object?
    If you know what coproducts are: does it have coproducts?
-/

-- TODO

/-
Problem 7:
    Suppose a category $\mathcal{C}$ has products. Prove that for any objects $A,B$, and $C$,
    it is the case that $(A \times B) \times C \cong A \times (B \times C)$ (recall that $\cong$
    means isomorphism of objects).

    Note: This may take a lot of space. We will see a better way to prove this later.
-/

noncomputable def create_product_isomorphic_assoc {T : Type*} [𝒞 : Category T] {A B C : T}
  [ab : Limits.HasBinaryProduct A B] [axb_c : Limits.HasBinaryProduct (Limits.prod A B) C]
    [bc : Limits.HasBinaryProduct B C] [a_bxc : Limits.HasBinaryProduct A (Limits.prod B C)] :
      Limits.prod (Limits.prod A B) C ≅ Limits.prod A (Limits.prod B C) where
  hom := Limits.prod.lift
    (Limits.prod.fst ≫ Limits.prod.fst)
    (Limits.prod.lift (Limits.prod.fst ≫ Limits.prod.snd) Limits.prod.snd)
  inv := Limits.prod.lift
    (Limits.prod.lift Limits.prod.fst (Limits.prod.snd ≫ Limits.prod.fst))
    (Limits.prod.snd ≫ Limits.prod.snd)
  hom_inv_id := by ext <;> simp
  inv_hom_id := by ext <;> simp

theorem product_isomorphic_assoc {T : Type*} [𝒞 : Category T] {A B C : T}
  [ab : Limits.HasBinaryProduct A B] [axb_c : Limits.HasBinaryProduct (Limits.prod A B) C]
    [bc : Limits.HasBinaryProduct B C] [a_bxc : Limits.HasBinaryProduct A (Limits.prod B C)] :
      Nonempty (Limits.prod (Limits.prod A B) C ≅ Limits.prod A (Limits.prod B C)) := by
  constructor
  exact create_product_isomorphic_assoc

/-
Problem 8:
    Let \(X\) be an object of \(\mathsf{FinSet}\).
    Show that elements of \(X\) (when considered as a finite set)
    are in bijection with morphisms in \(\mathsf{FinSet}\)
    from \(1\) to \(X\),
    where \(1\) is the terminal object of \(\mathsf{FinSet}\).
-/

-- TODO

/-
Problem 9:
    Suppose \(U\) and \(V\) are subsets of a finite set \(X\).
    Show that \(U \subseteq V\) if and only if
    there exists a dashed \(\FinSet\)-morphism \(f\)
    such that \(f \circ v = u\),
    where \(u\) and \(v\) are the \(\FinSet\)-morphisms
    corresponding to the inclusion functions \(U \to X\) and \(V \to X\)
    respectively:
    \begin{equation}
      % https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZABgBpiBdUkANwEMAbAVxiRAFUQBfU9TXfIRQAmclVqMWbAGrdeIDNjwEiARlKrx9Zq0QgAGt3EwoAc3hFQAMwBOEALZIyIHBCSiXdLAzY4vP6m0pPSYQagY6ACMYBgAFfmUhEBssUwALHDlrO0dEdRc3RA8-b19-MIkdNhoskFsHJ2pXJHySnz1IMFZwrC62KDo4NJMKoN06oy4gA
    \begin{tikzcd}
    U \arrow[rd, "u"'] \arrow[rr, "f", dashed] &   & V \arrow[ld, "v"] \\
                                                    & X &
    \end{tikzcd}
    \end{equation}
-/

-- TODO
