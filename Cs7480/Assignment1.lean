import Mathlib.CategoryTheory.Category.Basic
import Mathlib.Data.Fintype.Defs
import Mathlib.Data.Finset.Powerset

/-
Problem 1: $\mathsf{Formula}$: the category of syntactic Boolean formulae and entailment]
  Consider the following grammar of Boolean formulae:
  \begin{align}
    \varphi, \psi ::= x \mid \varphi \land \psi \mid \varphi \lor \psi \mid \neg \psi
  \end{align}
  Fix a global finite set of variable names $\Omega$, and assume $x \in \Omega$.
  Then, we can give a semantics to Boolean formulae in terms of substitutions.
  A
  substitution $\gamma$ is a function $\Omega \to \{\top, \bot\}$ that maps each variable
  to a truth value. Then, we can define the semantics of formulae inductively:

  \begin{align*}
    \dbracket{x}(\gamma) &= \gamma(x)\\
    \dbracket{\varphi \land \psi}(\gamma) &= \begin{cases}
    \top \quad& \text{if } \dbracket{\varphi}(\gamma) = \top, \dbracket{\psi}(\gamma) = \top\\
    \bot \quad& \text{otherwise}
    \end{cases}\\
    \dbracket{\varphi \lor \psi}(\gamma) &= \begin{cases}
    \bot \quad& \text{if } \dbracket{\varphi}(\gamma) = \bot, \dbracket{\psi}(\gamma) = \bot\\
    \top \quad& \text{otherwise}
    \end{cases}\\
    \dbracket{\neg \varphi}(\gamma) &= \begin{cases}
    \top \quad& \text{if } \dbracket{\varphi}(\gamma) = \bot\\
    \bot \quad& \text{if } \dbracket{\varphi}(\gamma) = \top
    \end{cases}
  \end{align*}

  The \emph{set of models}, written $\mathsf{Mods}(\varphi)$, is the set of all substitutions
  that evaluate to
  $\top$, i.e. $\mathsf{Mods}(\varphi) = \{\gamma \mid \dbracket{\varphi}(\gamma) = \top\}$.
  We say a formula
  $\varphi$ \emph{semantically entails} a formula $\psi$, written $\varphi \models \psi$,
  if $\mathsf{Mods}(\varphi) \subseteq \mathsf{Mods}(\psi)$.


    Consider the following components of a category whose objects are
    Boolean formula and whose morphisms denote formula entailment:
    \begin{itemize}
      \item Let the set of objects $O$ be the set of all syntactic Boolean
      formulae generated by the above grammar.
      \item The set of morphisms $M$ consists of pairs $(\varphi, \psi)$ where
      $\varphi \models \psi$.
      \item Define $\mathsf{dom}(\varphi, \psi) = \varphi, \mathsf{cod}(\varphi, \psi) = \psi$
      \item Identity is defined by $\mathsf{id}(\phi) = (\phi, \phi)$
      \item Composition is defined by $\mathsf{comp}((\psi, \xi), (\varphi, \psi)) = (\varphi, \xi)$
    \end{itemize}
    Verify that the above satisfy the definition of a category.
    This will involve showing that some entailments are valid.
-/

inductive Formula (Name : Type) where
  | var (name : Name)
  | top
  | bot
  | and (φ : Formula Name) (ψ : Formula Name)
  | or (φ : Formula Name) (ψ : Formula Name)
  | not (φ : Formula Name)

def Subst (Name : Type) := Name → Bool

def eval {Name : Type} : Formula Name → Subst Name → Bool
  | Formula.var x, γ => γ x
  | Formula.top, _ => true
  | Formula.bot, _ => false
  | Formula.and φ ψ, γ => and (eval ψ γ) (eval φ γ)
  | Formula.or φ ψ, γ => or (eval ψ γ) (eval φ γ)
  | Formula.not φ, γ => not (eval φ γ)

-- the set of substitutions which evaluate to true
def Mods {Name : Type} (φ : Formula Name) : Set (Subst Name) :=
  {γ | eval φ γ = true}

-- semantic entailment
def entails {Name : Type} (φ ψ : Formula Name) : Prop :=
  Mods φ ⊆ Mods ψ

instance formulaCategory {Name : Type} : CategoryTheory.Category (Formula Name) where
  -- Prop isn't in the correct type universe (because of Name), so we must lift it
  Hom φ ψ := PLift (entails φ ψ)
  -- straightforward-ly, the identity and composition functions
  id φ := by
    apply PLift.up
    intro γ hγ
    exact hγ
  comp {φ ψ x} h₁ h₂ := by
    apply PLift.up
    apply PLift.down at h₁
    apply PLift.down at h₂
    intro γ hγ
    exact h₂ (h₁ hγ)
  -- because comp and id are straightforward, so are the left and right id composition laws
  id_comp := by
    simp only
    intro x y f
    trivial
  comp_id := by
    simp only
    intro x y f
    trivial
  -- assoc is also pretty straightforward, but not as easy as id_comp and comp_id
  assoc {w x y z} h₁ h₂ h₃ := by
    rw [PLift.down]
    exact h₃
